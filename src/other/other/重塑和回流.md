## 浏览器的渲染过程

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
4. Painting(重绘)重排:根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. isplay:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层

### 生成渲染树：渲染树只包含可见的节点
1. 从DOM树的根节点开始遍历每个可见节点。
2. 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。
3. 根据每个可见节点以及其对应的样式，组合生成渲染树。
   * 一些不会渲染输出的节点，比如script、meta、link等。
   * 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。

### 回流

通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流
* 页面首次加载
* 浏览器窗口尺寸改变
* 元素尺寸或位置改变
* 元素内容变化
* 元素字体大小变化
* 增删 DOM 元素
* 查询或调用某些特定属性方法

### 重绘
我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。


### 结论
* 回流往往代价比重绘大
* 回流一定重绘，重绘未必回流。

### 优化

* 避免使用 CSS 表达式；
* 使用 transform 替代 top；
* CSS3 硬件加速（GPU 加速）；
* 尽可能在 DOM 树的最末端改变 class：减小回流的范围；
* JS 避免频繁读取会引发回流/重绘的属性：如果需要频繁使用，可以用变量把它缓存下来
* 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流；
* 离线操作 DOM：把元素脱离文档流，然后对元素进行修改，这样只会导致重绘，而不会造成回流。
  * display:none：临时把元素 脱离文档流，进行批量操作后再放回。这样只会有一次回流
  * createDocumentFragment：创建文档片段，一次性把内容放进文档；（批量修改DOM）

### 其他

1. 因为频繁修改 DOM 或 CSSOM 本身是件特别耗费性能的事情，现代浏览器大多对于都
做了一定的优化。比如会把一系列的操作放进队列机制来批量更新布局，至少一个浏览器
刷新帧 16ms（即大多数显示屏幕的刷新率为 60Hz,一个刷新间隔为 1000ms/60）才会清空队列（节流优化~）。
document fragment
